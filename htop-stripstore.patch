diff --git a/linux/LinuxProcessList.c b/linux/LinuxProcessList.c
index 712baa5..fb2e2d3 100644
--- a/linux/LinuxProcessList.c
+++ b/linux/LinuxProcessList.c
@@ -456,6 +456,13 @@ static void setCommand(Process* process, const char* command, int len) {
    process->commLen = len;
 }
 
+static bool isHashChar(char c) {
+    return '0' <= c && c <= '9'
+        || 'a' <= c && c <= 'z' && c != 'e' && c != 'o' && c != 't' && c != 'u';
+}
+
+static const char * STORE_PATH = "/nix/store/";
+static const int HASH_LENGTH = 32;
 static bool LinuxProcessList_readCmdlineFile(Process* process, const char* dirname, const char* name) {
    if (Process_isKernelThread(process))
       return true;
@@ -487,6 +494,31 @@ static bool LinuxProcessList_readCmdlineFile(Process* process, const char* dirna
    }
    command[lastChar + 1] = '\0';
    process->basenameOffset = tokenEnd;
+
+   // Strip out nix store paths. This is horrid.
+   int comm_len = strlen(command);
+   int pos_out = 0;
+   for (int pos_in = 0; pos_in < comm_len;) {
+      // Found a store path?
+      if (strncmp(command + pos_in, STORE_PATH, strlen(STORE_PATH)) == 0) {
+         bool skip = true;
+         int pos_in2 = pos_in + strlen(STORE_PATH);
+         // Check if there is indeed a full hash
+         while (pos_in2 < comm_len && pos_in2 < pos_in + strlen(STORE_PATH) + HASH_LENGTH - 1) {
+            pos_in2++;
+            if (!isHashChar(command[pos_in2])) {
+               skip = false;
+               break;
+            }
+         }
+         if (skip)
+            pos_in += strlen(STORE_PATH) + HASH_LENGTH;
+         command[pos_out++] = '$';
+      }
+      command[pos_out++] = command[pos_in++];
+   }
+   command[pos_out++] = '\0';
+
    setCommand(process, command, lastChar + 1);
 
    return true;
